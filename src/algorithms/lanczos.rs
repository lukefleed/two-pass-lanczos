//! This module provides implementations of the symmetric Lanczos algorithm.
//!
//! It includes the standard one-pass algorithm, which generates and stores the basis
//! vectors, and a memory-efficient two-pass variant that regenerates the basis vectors
//! in a second pass to avoid storing them. The implementations are generic and
//! operate on any type that implements the `faer::matrix_free::LinOp` trait.

use crate::error::{LanczosError, LanczosErrorKind};
use faer::traits::math_utils::{add, mul, sub};
use faer::{
    Par,
    dyn_stack::MemStack,
    matrix_free::LinOp,
    prelude::*,
    traits::{ComplexField, RealField},
};

/// A read-only view of a tridiagonal matrix generated by the Lanczos process.
///
/// This struct provides zero-allocation access to tridiagonal matrix data
/// by referencing existing slices. It is used primarily for callbacks to inspect
/// the state of the Lanczos process without data duplication.
#[derive(Debug)]
pub struct TridiagonalSystemView<'a, R: RealField> {
    /// The diagonal elements of the tridiagonal matrix (α_j).
    pub alphas: &'a [R],
    /// The super/sub-diagonal elements of the tridiagonal matrix (β_j).
    pub betas: &'a [R],
    /// The actual number of steps performed before breakdown or completion.
    pub steps_taken: usize,
}

/// A callback function invoked at each step of the Lanczos iteration.
///
/// # Arguments
/// * `k`: The current iteration number (1-based).
/// * `v_k`: An immutable view of the basis vectors `[v_1, ..., v_k]` generated so far.
/// * `t_k_view`: A non-owning view of the tridiagonal matrix `T_k` generated so far.
///
/// # Returns
/// `true` to continue the iteration, `false` to request an early stop.
pub type LanczosCallback<T> = dyn for<'a> FnMut(
    usize,
    MatRef<'a, T>,
    &'a TridiagonalSystemView<'a, <T as ComplexField>::Real>,
) -> bool;

/// Contains the scalar data resulting from a Lanczos process.
///
/// This struct holds all necessary data to define the tridiagonal system `T_k` and
/// to reconstruct the solution in a subsequent pass.
#[derive(Debug, Clone)]
pub struct LanczosDecomposition<R: RealField> {
    /// The diagonal elements of the tridiagonal matrix (α_j).
    pub alphas: Vec<R>,
    /// The super/sub-diagonal elements of the tridiagonal matrix (β_j).
    /// `betas[j-1]` corresponds to β_j for j = 1, ..., steps_taken-1.
    /// The length is always `steps_taken - 1`.
    pub betas: Vec<R>,
    /// The actual number of steps performed before breakdown or completion.
    pub steps_taken: usize,
    /// The L2 norm of the initial vector `b`.
    pub b_norm: R,
}

/// Contains the complete output of the standard one-pass Lanczos algorithm.
///
/// This includes both the orthonormal basis vectors and the full scalar decomposition.
#[derive(Debug)]
pub struct LanczosOutput<T: ComplexField> {
    /// The matrix V_k whose columns are the orthonormal Lanczos basis vectors.
    pub v_k: Mat<T>,
    /// The scalar data from the Lanczos process, including T_k and the initial vector norm.
    pub decomposition: LanczosDecomposition<T::Real>,
}

/// Contains the output of the second pass, including the regenerated basis.
/// This struct is exposed only for testing purposes via conditional compilation.
#[derive(Debug)]
pub struct LanczosPassTwoOutput<T: ComplexField> {
    /// The final approximate solution vector `x_k`.
    pub x_k: Mat<T>,
    /// The regenerated basis matrix `V_k`.
    pub v_k: Mat<T>,
}

/// Computes the tolerance for breakdown detection based on machine epsilon.
///
/// This provides better numerical robustness than hardcoded tolerances.
fn breakdown_tolerance<T: RealField>() -> T {
    // A small multiple of machine epsilon is a standard choice for breakdown detection.
    T::from_f64_impl(f64::EPSILON * 1000.0)
}

/// Performs a single step of the Lanczos recurrence relation.
///
/// This function implements the core three-term recurrence:
/// β_j v_{j+1} = A v_j - α_j v_j - β_{j-1} v_{j-1}
///
/// The result is written to the provided mutable matrix view `w`, which should be
/// pre-allocated by the caller. It returns the scalar coefficient α_j and an
/// `Option<β_j>`. A `None` value for β_j indicates that a breakdown has occurred
/// (β_j is numerically zero), and the iteration should terminate.
///
/// # Arguments
/// * `operator`: The linear operator A.
/// * `w`: Pre-allocated mutable matrix view for the output vector.
/// * `v_curr`: Current Lanczos vector v_j.
/// * `v_prev`: Previous Lanczos vector v_{j-1}.
/// * `beta_prev`: Previous beta coefficient β_{j-1}.
/// * `stack`: Memory stack for temporary allocations required by the operator.
///
/// # Returns
/// A tuple containing (α_j, Option<β_j>).
fn lanczos_recurrence_step<T: ComplexField, O: LinOp<T>>(
    operator: &O,
    mut w: MatMut<'_, T>,
    v_curr: MatRef<'_, T>,
    v_prev: MatRef<'_, T>,
    beta_prev: T::Real,
    stack: &mut MemStack,
) -> (T::Real, Option<T::Real>) {
    // Apply the operator: w = A * v_curr
    operator.apply(w.rb_mut(), v_curr, Par::Seq, stack);

    // Orthogonalize w against the previous Lanczos vector v_{j-1}.
    // This performs the operation w <- w - β_{j-1} * v_{j-1} in-place.
    let beta_prev_scaled = T::from_real_impl(&beta_prev);
    zip!(w.rb_mut(), v_prev).for_each(|unzip!(w_i, v_prev_i)| {
        *w_i = sub(w_i, &mul(&beta_prev_scaled, v_prev_i));
    });

    // Compute the diagonal element α_j = v_j^H * w.
    // At this point, w = A*v_j - β_{j-1}*v_{j-1}, which is the correct
    // intermediate vector for computing α_j.
    let alpha = T::real_part_impl(&(v_curr.adjoint() * w.rb())[(0, 0)]);

    // Orthogonalize w against the current Lanczos vector v_j.
    // This performs the operation w <- w - α_j * v_j in-place.
    let alpha_scaled = T::from_real_impl(&alpha);
    zip!(w.rb_mut(), v_curr).for_each(|unzip!(w_i, v_curr_i)| {
        *w_i = sub(w_i, &mul(&alpha_scaled, v_curr_i));
    });

    // Compute the off-diagonal element β_j = ||w||_2.
    // w is now the unnormalized next Lanczos vector, r_j.
    let beta = w.rb().norm_l2();

    // Check for breakdown. If β_j is close to zero, the Krylov subspace
    // is invariant, and the iteration must stop.
    let tolerance = breakdown_tolerance::<T::Real>();
    if beta <= tolerance {
        (alpha, None)
    } else {
        (alpha, Some(beta))
    }
}

struct LanczosStep<T: ComplexField> {
    /// The diagonal element α_j.
    alpha: T::Real,
    /// The off-diagonal element β_j.
    beta: T::Real,
}

/// Private struct that encapsulates the state of the Lanczos iteration.
///
/// This struct provides a clean, stateful representation of the Lanczos
/// recurrence, which can be consumed by different algorithm implementations.
/// It manages work vectors to avoid repeated heap allocations.
struct LanczosIteration<'a, T: ComplexField, O: LinOp<T>> {
    /// A reference to the linear operator.
    operator: &'a O,
    /// The previous Lanczos vector, v_{j-1}.
    v_prev: Mat<T>,
    /// The current Lanczos vector, v_j.
    v_curr: Mat<T>,
    /// Work vector for intermediate computations.
    work: Mat<T>,
    /// The previous beta coefficient, β_{j-1}.
    beta_prev: T::Real,
    /// The current iteration number.
    k: usize,
    /// The maximum number of iterations to perform.
    max_k: usize,
}

impl<'a, T: ComplexField, O: LinOp<T>> LanczosIteration<'a, T, O>
where
    T::Real: RealField,
{
    /// Creates a new `LanczosIteration` instance.
    ///
    /// # Arguments
    /// * `b_norm`: The pre-computed L2 norm of the initial vector `b`.
    ///
    /// # Returns
    /// A `Result` containing the new instance or a `LanczosError` if the input vector is zero.
    fn new(
        operator: &'a O,
        b: MatRef<'_, T>,
        max_k: usize,
        b_norm: T::Real,
    ) -> Result<Self, LanczosError> {
        let zero_threshold = breakdown_tolerance::<T::Real>();
        if b_norm <= zero_threshold {
            return Err(LanczosErrorKind::InputError(
                "Input vector `b` must not be a zero vector.".to_string(),
            )
            .into());
        }

        // Normalize the initial vector efficiently using the pre-computed norm.
        let inv_norm = T::from_real_impl(&T::Real::recip_impl(&b_norm));
        let v1 = &b * Scale(inv_norm);

        Ok(Self {
            operator,
            v_prev: Mat::zeros(b.nrows(), 1),
            v_curr: v1,
            work: Mat::zeros(b.nrows(), 1),
            beta_prev: T::Real::zero_impl(),
            k: 0,
            max_k,
        })
    }

    /// Performs the next step of the Lanczos iteration.
    fn next_step(&mut self, stack: &mut MemStack) -> Option<LanczosStep<T>> {
        if self.k >= self.max_k {
            return None;
        }

        // Use the reusable recurrence function with pre-allocated work vector.
        let (alpha, beta_option) = lanczos_recurrence_step(
            self.operator,
            self.work.as_mut(),
            self.v_curr.as_ref(),
            self.v_prev.as_ref(),
            T::Real::copy_impl(&self.beta_prev),
            stack,
        );

        self.k += 1;

        match beta_option {
            Some(beta) => {
                // Normalize: v_{j+1} = work / β_j (in-place)
                let inv_beta = T::from_real_impl(&T::Real::recip_impl(&beta));
                zip!(self.work.as_mut()).for_each(|unzip!(w_i)| {
                    *w_i = mul(w_i, &inv_beta);
                });

                // Update state for the next iteration using move semantics (no cloning).
                // Swap the vectors to avoid cloning: v_prev <- v_curr, v_curr <- work
                core::mem::swap(&mut self.v_prev, &mut self.v_curr);
                core::mem::swap(&mut self.v_curr, &mut self.work);
                self.beta_prev = T::Real::copy_impl(&beta);

                Some(LanczosStep {
                    alpha,
                    beta: T::Real::copy_impl(&beta),
                })
            }
            None => {
                // Breakdown occurred. Return the computed alpha but a zero beta.
                Some(LanczosStep {
                    alpha,
                    beta: T::Real::zero_impl(),
                })
            }
        }
    }
}

/// Performs the standard one-pass symmetric Lanczos algorithm.
///
/// This function executes `k` steps of the Lanczos process, storing the generated
/// basis vectors in the columns of the matrix `v_k`. An optional callback function
/// can be provided to observe the algorithm's state at each iteration.
///
/// # Arguments
/// * `operator`: A linear operator that implements `faer::matrix_free::LinOp`.
/// * `b`: The starting vector. Must not be a zero vector.
/// * `k`: The number of iterations to perform.
/// * `stack`: Memory stack for temporary allocations.
/// * `callback`: An optional mutable reference to a callback function invoked at each iteration.
///
/// # Returns
/// A `Result` containing the `LanczosOutput` on success, or a `LanczosError` on failure.
pub fn lanczos_standard<T: ComplexField>(
    operator: &impl LinOp<T>,
    b: MatRef<'_, T>,
    k: usize,
    stack: &mut MemStack,
    mut callback: Option<&mut LanczosCallback<T>>,
) -> Result<LanczosOutput<T>, LanczosError>
where
    T::Real: RealField,
{
    let b_norm = b.norm_l2();
    let mut v_k = Mat::<T>::zeros(operator.nrows(), k);
    let mut alphas = Vec::with_capacity(k);
    let mut betas = Vec::with_capacity(k - 1);

    let mut lanczos_iter = LanczosIteration::new(operator, b, k, T::Real::copy_impl(&b_norm))?;
    v_k.col_mut(0)
        .copy_from(lanczos_iter.v_curr.as_ref().col(0));

    let mut steps_taken = 0;

    for i in 0..k {
        if let Some(step) = lanczos_iter.next_step(stack) {
            alphas.push(step.alpha);
            steps_taken += 1;

            // If a callback is provided, invoke it with the current state.
            if let Some(ref mut cb) = callback {
                let current_v_k = v_k.as_ref().get(.., 0..steps_taken);
                // Create a temporary view for the callback.
                let t_k_view = TridiagonalSystemView {
                    alphas: &alphas,
                    betas: &betas,
                    steps_taken,
                };

                // Invoke the callback; if it returns false, stop the iteration.
                if !cb(steps_taken, current_v_k, &t_k_view) {
                    break;
                }
            }

            // A zero beta indicates that breakdown has occurred.
            let tolerance = breakdown_tolerance::<T::Real>();
            if step.beta <= tolerance {
                break;
            }

            if i < k - 1 {
                betas.push(step.beta);
                // Copy the current vector from the iterator state after the step
                v_k.col_mut(i + 1)
                    .copy_from(lanczos_iter.v_curr.as_ref().col(0));
            }
        } else {
            break;
        }
    }

    Ok(LanczosOutput {
        v_k: v_k.as_ref().get(.., 0..steps_taken).to_owned(),
        decomposition: LanczosDecomposition {
            alphas,
            betas,
            steps_taken,
            b_norm,
        },
    })
}

/// Performs the first pass of the two-pass Lanczos algorithm.
///
/// This pass computes the scalar decomposition of the operator's action on `b`,
/// without storing the Lanczos basis vectors, resulting in an O(n) memory footprint.
///
/// # Arguments
/// * `operator`: A linear operator that implements `faer::matrix_free::LinOp`.
/// * `b`: The starting vector. Must not be a zero vector.
/// * `k`: The number of iterations to perform.
/// * `stack`: Memory stack for temporary allocations.
///
/// # Returns
/// A `Result` containing the `LanczosDecomposition` on success, or a `LanczosError`.
pub fn lanczos_pass_one<T: ComplexField>(
    operator: &impl LinOp<T>,
    b: MatRef<'_, T>,
    k: usize,
    stack: &mut MemStack,
) -> Result<LanczosDecomposition<T::Real>, LanczosError>
where
    T::Real: RealField,
{
    let b_norm = b.norm_l2();
    let mut alphas = Vec::with_capacity(k);
    let mut betas = Vec::with_capacity(k - 1);

    let mut lanczos_iter = LanczosIteration::new(operator, b, k, T::Real::copy_impl(&b_norm))?;

    let mut steps_taken = 0;

    for i in 0..k {
        if let Some(step) = lanczos_iter.next_step(stack) {
            alphas.push(step.alpha);
            steps_taken += 1;

            // A zero beta indicates that breakdown has occurred.
            let tolerance = breakdown_tolerance::<T::Real>();
            if step.beta <= tolerance {
                break;
            }

            if i < k - 1 {
                betas.push(step.beta);
            }
        } else {
            break;
        }
    }

    Ok(LanczosDecomposition {
        alphas,
        betas,
        steps_taken,
        b_norm,
    })
}

/// Performs the second pass of the two-pass Lanczos algorithm.
///
/// This pass reconstructs the solution vector `x_k = V_k * y_k` by regenerating the
/// Lanczos basis vectors on-the-fly using the coefficients from the first pass.
///
/// # Arguments
/// * `operator`: A linear operator that implements `faer::matrix_free::LinOp`.
/// * `b`: The original starting vector.
/// * `decomposition`: The scalar data generated by `lanczos_pass_one`.
/// * `y_k`: The coefficient vector, typically computed as `f(T_k) * e_1 * ||b||`.
/// * `stack`: Memory stack for temporary allocations.
///
/// # Returns
/// A `Result` containing the final approximate solution vector `x_k`.
pub fn lanczos_pass_two<T: ComplexField>(
    operator: &impl LinOp<T>,
    b: MatRef<'_, T>,
    decomposition: &LanczosDecomposition<T::Real>,
    y_k: MatRef<'_, T>,
    stack: &mut MemStack,
) -> Result<Mat<T>, LanczosError>
where
    T::Real: RealField,
{
    // This is a thin wrapper around the core implementation, configured to not
    // store the regenerated basis, ensuring minimal memory usage for the public API.
    let (x_k, _) = lanczos_pass_two_impl(operator, b, decomposition, y_k, stack, false)?;
    Ok(x_k)
}

/// A test-only variant of `lanczos_pass_two` that also returns the regenerated basis.
///
/// This function is identical to `lanczos_pass_two` but additionally returns the
/// regenerated basis matrix `V_k`. It is compiled only during testing and is
/// used to verify the numerical stability of the regeneration process.
pub fn lanczos_pass_two_with_basis<T: ComplexField>(
    operator: &impl LinOp<T>,
    b: MatRef<'_, T>,
    decomposition: &LanczosDecomposition<T::Real>,
    y_k: MatRef<'_, T>,
    stack: &mut MemStack,
) -> Result<LanczosPassTwoOutput<T>, LanczosError>
where
    T::Real: RealField,
{
    // Call the core implementation, configured to store the basis for testing.
    let (x_k, v_k_option) = lanczos_pass_two_impl(operator, b, decomposition, y_k, stack, true)?;
    // The `v_k_option` is guaranteed to be `Some` because `store_basis` is true.
    Ok(LanczosPassTwoOutput {
        x_k,
        v_k: v_k_option.unwrap(),
    })
}

/// Core implementation of the second Lanczos pass.
///
/// This private function contains the logic to regenerate the basis and reconstruct
/// the solution. It can be configured to either store the basis (for testing) or
/// discard it (for production use).
fn lanczos_pass_two_impl<T: ComplexField>(
    operator: &impl LinOp<T>,
    b: MatRef<'_, T>,
    decomposition: &LanczosDecomposition<T::Real>,
    y_k: MatRef<'_, T>,
    stack: &mut MemStack,
    store_basis: bool,
) -> Result<(Mat<T>, Option<Mat<T>>), LanczosError>
where
    T::Real: RealField,
{
    if decomposition.steps_taken != y_k.nrows() {
        return Err(LanczosErrorKind::DimensionMismatch {
            operator_cols: decomposition.steps_taken,
            vector_rows: y_k.nrows(),
        }
        .into());
    }

    let zero_threshold = breakdown_tolerance::<T::Real>();
    if decomposition.b_norm <= zero_threshold {
        return Err(LanczosErrorKind::InputError(
            "The initial vector `b` must not be a zero vector.".to_string(),
        )
        .into());
    }

    if decomposition.steps_taken == 0 {
        let v_k = if store_basis {
            Some(Mat::zeros(b.nrows(), 0))
        } else {
            None
        };
        return Ok((Mat::zeros(b.nrows(), 1), v_k));
    }

    let mut v_prev = Mat::<T>::zeros(b.nrows(), 1);
    let inv_norm = T::from_real_impl(&T::Real::recip_impl(&decomposition.b_norm));
    let mut v_curr = &b * Scale(inv_norm);

    let mut x_k = &v_curr * Scale(T::copy_impl(&y_k[(0, 0)]));
    let mut v_k_regen = if store_basis {
        let mut m = Mat::zeros(b.nrows(), decomposition.steps_taken);
        m.col_mut(0).copy_from(v_curr.as_ref().col(0));
        Some(m)
    } else {
        None
    };

    let mut work = Mat::<T>::zeros(b.nrows(), 1);

    for j in 0..decomposition.steps_taken - 1 {
        let alpha_j = T::Real::copy_impl(&decomposition.alphas[j]);
        let beta_j = T::Real::copy_impl(&decomposition.betas[j]);
        let beta_prev = if j == 0 {
            T::Real::zero_impl()
        } else {
            T::Real::copy_impl(&decomposition.betas[j - 1])
        };

        let (computed_alpha, computed_beta_option) = lanczos_recurrence_step(
            operator,
            work.as_mut(),
            v_curr.as_ref(),
            v_prev.as_ref(),
            beta_prev,
            stack,
        );

        #[cfg(debug_assertions)]
        {
            let tolerance = breakdown_tolerance::<T::Real>() * T::Real::from_f64_impl(10.0);
            let alpha_diff = T::Real::abs_impl(&sub(&computed_alpha, &alpha_j));
            if alpha_diff > tolerance {
                eprintln!(
                    "Warning: Alpha mismatch in second pass at step {j}: stored={:?}, computed={:?}",
                    alpha_j, computed_alpha
                );
            }
            if let Some(ref computed_beta) = computed_beta_option {
                let beta_diff = T::Real::abs_impl(&sub(computed_beta, &beta_j));
                if beta_diff > tolerance {
                    eprintln!(
                        "Warning: Beta mismatch in second pass at step {j}: stored={:?}, computed={:?}",
                        beta_j, computed_beta
                    );
                }
            }
        }

        if computed_beta_option.is_none() {
            return Err(LanczosErrorKind::InputError(format!(
                "Unexpected breakdown in second pass at step {}",
                j
            ))
            .into());
        }

        let inv_beta = T::from_real_impl(&T::Real::recip_impl(&beta_j));
        zip!(work.as_mut()).for_each(|unzip!(w_i)| {
            *w_i = mul(w_i, &inv_beta);
        });

        let coeff = T::copy_impl(&y_k[(j + 1, 0)]);
        zip!(x_k.as_mut(), work.as_ref()).for_each(|unzip!(x_i, v_i)| {
            *x_i = add(x_i, &mul(&coeff, v_i));
        });

        core::mem::swap(&mut v_prev, &mut v_curr);
        core::mem::swap(&mut v_curr, &mut work);

        if let Some(m) = v_k_regen.as_mut() {
            m.col_mut(j + 1).copy_from(v_curr.as_ref().col(0));
        }
    }

    Ok((x_k, v_k_regen))
}

#[cfg(test)]
mod tests {
    use super::*;
    use faer::dyn_stack::MemBuffer;

    /// Sets up a simple, well-defined test problem using a small, symmetric matrix.
    /// The matrix is a discrete 1D Laplacian, which is symmetric positive-definite.
    fn setup_test_problem() -> (Mat<f64>, Mat<f64>) {
        let a: Mat<f64> = mat![
            [2.0, -1.0, 0.0, 0.0],
            [-1.0, 2.0, -1.0, 0.0],
            [0.0, -1.0, 2.0, -1.0],
            [0.0, 0.0, -1.0, 2.0],
        ];
        let b: Mat<f64> = mat![[1.0], [0.0], [0.0], [0.0]];
        (a, b)
    }

    /// Tests the private `lanczos_recurrence_step` function to ensure the core
    /// arithmetic for a single step is correct.
    #[test]
    fn test_recurrence_step_correctness() {
        let (a, _) = setup_test_problem();
        let mut mem = MemBuffer::new(a.apply_scratch(1, Par::Seq));
        let mut stack = MemStack::new(&mut mem);

        let v_curr: Mat<f64> = mat![[1.0], [0.0], [0.0], [0.0]];
        let v_prev: Mat<f64> = Mat::zeros(4, 1);
        let beta_prev = 0.0;

        let mut work = Mat::<f64>::zeros(4, 1);
        let (alpha, beta_option) = lanczos_recurrence_step(
            &a.as_ref(),
            work.as_mut(),
            v_curr.as_ref(),
            v_prev.as_ref(),
            beta_prev,
            &mut stack,
        );

        let beta = beta_option.unwrap();
        assert!((alpha - 2.0).abs() < 1e-15);
        assert!((beta - 1.0).abs() < 1e-15);
    }

    /// Tests the private `LanczosIteration` struct to verify that it produces the
    /// correct sequence of alpha and beta coefficients over several steps.
    #[test]
    fn test_iteration_produces_correct_sequence() {
        let (a, b) = setup_test_problem();
        let mut mem = MemBuffer::new(a.apply_scratch(1, Par::Seq));
        let mut stack = MemStack::new(&mut mem);
        let b_norm = b.norm_l2();

        let k = 3;
        let binding = a.as_ref();
        let mut iter = LanczosIteration::new(&binding, b.as_ref(), k, b_norm).unwrap();
        let mut computed_alphas = Vec::new();
        let mut computed_betas = Vec::new();

        for i in 0..k {
            if let Some(step) = iter.next_step(&mut stack) {
                computed_alphas.push(step.alpha);

                if step.beta <= breakdown_tolerance() {
                    break;
                }

                if i < k - 1 {
                    computed_betas.push(step.beta);
                }
            } else {
                break;
            }
        }

        // For the 1D discrete Laplacian, alphas are 2.0 and betas are 1.0.
        let expected_alphas = vec![2.0, 2.0, 2.0];
        let expected_betas = vec![1.0, 1.0];

        assert_eq!(computed_alphas.len(), 3);
        assert_eq!(computed_betas.len(), 2);
        for (actual, expected) in computed_alphas.iter().zip(expected_alphas.iter()) {
            assert!((actual - expected).abs() < 1e-14);
        }
        for (actual, expected) in computed_betas.iter().zip(expected_betas.iter()) {
            assert!((actual - expected).abs() < 1e-14);
        }
    }

    #[test]
    fn test_lanczos_standard_produces_correct_dimensions() {
        let (a, b) = setup_test_problem();
        let k = 3;
        let mut mem = MemBuffer::new(a.apply_scratch(1, Par::Seq));
        let mut stack = MemStack::new(&mut mem);

        let result = lanczos_standard(&a.as_ref(), b.as_ref(), k, &mut stack, None).unwrap();

        assert_eq!(result.v_k.nrows(), a.nrows());
        assert_eq!(result.v_k.ncols(), k);
        assert_eq!(result.decomposition.steps_taken, k);
        assert_eq!(result.decomposition.alphas.len(), k);
        assert_eq!(result.decomposition.betas.len(), k - 1);
        assert!((result.decomposition.b_norm - 1.0).abs() < 1e-15);
    }

    #[test]
    fn test_lanczos_pass_one_produces_correct_dimensions() {
        let (a, b) = setup_test_problem();
        let k = 3;
        let mut mem = MemBuffer::new(a.apply_scratch(1, Par::Seq));
        let mut stack = MemStack::new(&mut mem);

        let decomp = lanczos_pass_one(&a.as_ref(), b.as_ref(), k, &mut stack).unwrap();

        assert_eq!(decomp.steps_taken, k);
        assert_eq!(decomp.alphas.len(), k);
        assert_eq!(decomp.betas.len(), k - 1);
        assert!((decomp.b_norm - 1.0).abs() < 1e-15);
    }

    #[test]
    fn test_breakdown_scenario() {
        // A is diagonal, and b is an eigenvector.
        let a: Mat<f64> = mat![[2.0, 0.0], [0.0, 3.0]];
        let b: Mat<f64> = mat![[1.0], [0.0]];
        let k = 2; // Request 2 iterations, but it should stop after 1.
        let mut mem = MemBuffer::new(a.apply_scratch(1, Par::Seq));
        let mut stack = MemStack::new(&mut mem);

        let result = lanczos_standard(&a.as_ref(), b.as_ref(), k, &mut stack, None).unwrap();

        assert_eq!(result.decomposition.steps_taken, 1);
        assert_eq!(result.decomposition.alphas.len(), 1);
        assert_eq!(result.decomposition.betas.len(), 0);
        assert_eq!(result.v_k.ncols(), 1);
        assert!((result.decomposition.alphas[0] - 2.0).abs() < 1e-14);

        let decomp_pass_one = lanczos_pass_one(&a.as_ref(), b.as_ref(), k, &mut stack).unwrap();
        assert_eq!(decomp_pass_one.steps_taken, 1);
        assert_eq!(decomp_pass_one.alphas.len(), 1);
        assert_eq!(decomp_pass_one.betas.len(), 0);
        assert!((decomp_pass_one.alphas[0] - 2.0).abs() < 1e-14);
    }

    #[test]
    fn test_zero_vector_input_returns_error() {
        let a: Mat<f64> = Mat::identity(2, 2);
        let b: Mat<f64> = Mat::zeros(2, 1);
        let mut mem = MemBuffer::new(a.apply_scratch(1, Par::Seq));
        let mut stack = MemStack::new(&mut mem);

        let result_standard = lanczos_standard(&a, b.as_ref(), 2, &mut stack, None);
        assert!(result_standard.is_err());

        let result_pass_one = lanczos_pass_one(&a, b.as_ref(), 2, &mut stack);
        assert!(result_pass_one.is_err());

        let decomp = LanczosDecomposition {
            alphas: vec![],
            betas: vec![],
            steps_taken: 0,
            b_norm: 0.0,
        };
        let y_k: Mat<f64> = Mat::zeros(0, 1);
        let result_pass_two = lanczos_pass_two(&a, b.as_ref(), &decomp, y_k.as_ref(), &mut stack);
        assert!(result_pass_two.is_err());
    }
}
