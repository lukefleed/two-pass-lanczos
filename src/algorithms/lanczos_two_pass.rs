use super::{
    LanczosDecomposition, LanczosError, LanczosErrorKind, LanczosIteration, LanczosPassTwoOutput,
    breakdown_tolerance,
};
use faer::{
    Par,
    dyn_stack::MemStack,
    matrix_free::LinOp,
    prelude::*,
    traits::math_utils::{add, mul, sub},
    traits::{ComplexField, RealField},
};

/// Performs the first pass of the two-pass Lanczos algorithm.
///
/// This pass computes the scalar decomposition of the operator's action on `b` by
/// executing the Lanczos iteration without storing the basis vectors. The sole output
/// is the [`LanczosDecomposition`] struct, which contains the essential scalar data
/// ($\alpha_j$, $\beta_j$, and $\|\mathbf{b}\|_2$) needed to reconstruct the basis and
/// solution in the second pass. This approach results in a minimal $O(n)$ memory footprint.
///
/// # Arguments
/// * `operator`: A linear operator that implements [`faer::matrix_free::LinOp`].
/// * `b`: The starting vector. Must not be a zero vector.
/// * `k`: The maximum number of iterations to perform.
/// * `stack`: A `MemStack` for temporary allocations.
///
/// # Returns
/// A `Result` containing the [`LanczosDecomposition`] on success, or a [`LanczosError`].
pub(crate) fn lanczos_pass_one<T: ComplexField>(
    operator: &impl LinOp<T>,
    b: MatRef<'_, T>,
    k: usize,
    stack: &mut MemStack,
) -> Result<LanczosDecomposition<T::Real>, LanczosError>
where
    T::Real: RealField,
{
    let b_norm = b.norm_l2();
    let mut alphas = Vec::with_capacity(k);
    let mut betas = Vec::with_capacity(k - 1);

    // The stateful Lanczos iterator handles the vector recurrence. In this pass,
    // we only care about the scalar results of each step.
    let mut lanczos_iter = LanczosIteration::new(operator, b, k, T::Real::copy_impl(&b_norm))?;

    let mut steps_taken = 0;

    for i in 0..k {
        if let Some(step) = lanczos_iter.next_step(stack) {
            alphas.push(step.alpha);
            steps_taken += 1;

            // Check for breakdown, which terminates the process.
            let tolerance = breakdown_tolerance::<T::Real>();
            if step.beta <= tolerance {
                break;
            }

            // Store the off-diagonal element, but discard the basis vector.
            if i < k - 1 {
                betas.push(step.beta);
            }
        } else {
            break;
        }
    }

    Ok(LanczosDecomposition {
        alphas,
        betas,
        steps_taken,
        b_norm,
    })
}

/// Performs the second pass of the two-pass Lanczos algorithm.
///
/// This pass reconstructs the solution vector $\mathbf{x}_k = \mathbf{V}_k \mathbf{y}_k$
/// by regenerating the Lanczos basis vectors on-the-fly using the coefficients from the
/// first pass. It avoids storing the full basis, thus maintaining an $O(n)$ memory footprint.
///
/// This is a thin wrapper around the core implementation, `lanczos_pass_two_impl`,
/// configured to not store the regenerated basis, ensuring minimal memory usage for the public API.
///
/// # Arguments
/// * `operator`: The linear operator $\mathbf{A}$.
/// * `b`: The original starting vector.
/// * `decomposition`: The scalar data generated by `lanczos_pass_one`.
/// * `y_k`: The coefficient vector for the solution in the Lanczos basis, i.e.,
///   $\mathbf{y}_k = f(\mathbf{T}_k) \mathbf{e}_1 \|\mathbf{b}\|_2$.
/// * `stack`: A `MemStack` for temporary allocations.
///
/// # Returns
/// A `Result` containing the final approximate solution vector $\mathbf{x}_k$.
pub(crate) fn lanczos_pass_two<T: ComplexField>(
    operator: &impl LinOp<T>,
    b: MatRef<'_, T>,
    decomposition: &LanczosDecomposition<T::Real>,
    y_k: MatRef<'_, T>,
    stack: &mut MemStack,
) -> Result<Mat<T>, LanczosError>
where
    T::Real: RealField,
{
    let (x_k, _) = lanczos_pass_two_impl(operator, b, decomposition, y_k, stack, false)?;
    Ok(x_k)
}

/// A test-only variant of `lanczos_pass_two` that also returns the regenerated basis.
///
/// This function is identical to `lanczos_pass_two` but additionally returns the full
/// regenerated basis matrix $\mathbf{V}'_k$. It is used only during testing
/// and is used to verify the numerical stability and faithfulness of the regeneration process
/// by allowing a direct comparison with the basis stored by [`lanczos_standard`].
#[allow(dead_code)]
pub fn lanczos_pass_two_with_basis<T: ComplexField>(
    operator: &impl LinOp<T>,
    b: MatRef<'_, T>,
    decomposition: &LanczosDecomposition<T::Real>,
    y_k: MatRef<'_, T>,
    stack: &mut MemStack,
) -> Result<LanczosPassTwoOutput<T>, LanczosError>
where
    T::Real: RealField,
{
    // Call the core implementation, configured to store the basis for testing purposes.
    let (x_k, v_k_option) = lanczos_pass_two_impl(operator, b, decomposition, y_k, stack, true)?;
    // The `v_k_option` is guaranteed to be `Some` because `store_basis` is true.
    Ok(LanczosPassTwoOutput {
        x_k,
        v_k: v_k_option.unwrap(),
    })
}

/// A specialized recurrence step for the basis reconstruction in the second pass.
///
/// This function applies the Lanczos three-term recurrence using pre-computed
/// coefficients $\alpha_j$ and $\beta_{j-1}$ to regenerate the next unnormalized basis vector.
/// It avoids re-computing any coefficients, making it a pure reconstruction tool that is
/// both more efficient and numerically faithful to the sequence of operations in the first pass.
///
/// The recurrence applied is: $\mathbf{w} = \mathbf{A}\mathbf{v}_j - \alpha_j \mathbf{v}_j - \beta_{j-1}\mathbf{v}_{j-1}$.
fn lanczos_reconstruction_step<T: ComplexField, O: LinOp<T>>(
    operator: &O,
    mut w: MatMut<'_, T>,
    v_curr: MatRef<'_, T>,
    v_prev: MatRef<'_, T>,
    alpha_j: T::Real,
    beta_prev: T::Real,
    stack: &mut MemStack,
) {
    // 1. Apply the operator.
    operator.apply(w.rb_mut(), v_curr, Par::Seq, stack);

    // 2. Orthogonalize against the previous vector using the stored \beta_{j-1}.
    let beta_prev_scaled = T::from_real_impl(&beta_prev);
    zip!(w.rb_mut(), v_prev).for_each(|unzip!(w_i, v_prev_i)| {
        *w_i = sub(w_i, &mul(&beta_prev_scaled, v_prev_i));
    });

    // 3. Orthogonalize against the current vector using the stored \alpha_j.
    let alpha_scaled = T::from_real_impl(&alpha_j);
    zip!(w.rb_mut(), v_curr).for_each(|unzip!(w_i, v_curr_i)| {
        *w_i = sub(w_i, &mul(&alpha_scaled, v_curr_i));
    });
}

/// Core implementation of the second Lanczos pass.
///
/// This private function contains the logic to regenerate the basis and reconstruct the solution.
/// It can be configured via the `store_basis` flag to either store the full regenerated basis
/// (for testing and verification) or discard it (for production use, ensuring $O(n)$ memory).
fn lanczos_pass_two_impl<T: ComplexField>(
    operator: &impl LinOp<T>,
    b: MatRef<'_, T>,
    decomposition: &LanczosDecomposition<T::Real>,
    y_k: MatRef<'_, T>,
    stack: &mut MemStack,
    store_basis: bool,
) -> Result<(Mat<T>, Option<Mat<T>>), LanczosError>
where
    T::Real: RealField,
{
    // --- Input Validation ---
    // Ensure the coefficient vector `y_k` has the correct dimension, matching the
    // number of steps successfully completed in the first pass.
    if decomposition.steps_taken != y_k.nrows() {
        return Err(LanczosErrorKind::ParameterMismatch {
            param_name: "y_k".to_string(),
            expected: decomposition.steps_taken,
            actual: y_k.nrows(),
        }
        .into());
    }

    let zero_threshold = breakdown_tolerance::<T::Real>();
    if decomposition.b_norm <= zero_threshold {
        return Err(LanczosErrorKind::InputError(
            "The initial vector `b` must not be a zero vector.".to_string(),
        )
        .into());
    }

    if decomposition.steps_taken == 0 {
        let v_k = if store_basis {
            Some(Mat::zeros(b.nrows(), 0))
        } else {
            None
        };
        return Ok((Mat::zeros(b.nrows(), 1), v_k));
    }

    // --- Initialization ---
    let mut v_prev = Mat::<T>::zeros(b.nrows(), 1);
    let inv_norm = T::from_real_impl(&T::Real::recip_impl(&decomposition.b_norm));
    let mut v_curr = b * Scale(inv_norm); // This is v_1

    // Initialize the solution vector with the first component: x_k = y_1 * v_1
    let mut x_k = &v_curr * Scale(T::copy_impl(&y_k[(0, 0)]));

    // If requested, initialize the matrix for storing the regenerated basis.
    let mut v_k_regen = if store_basis {
        let mut m = Mat::zeros(b.nrows(), decomposition.steps_taken);
        m.col_mut(0).copy_from(v_curr.as_ref().col(0));
        Some(m)
    } else {
        None
    };

    let mut work = Mat::<T>::zeros(b.nrows(), 1);

    // --- Main Reconstruction Loop ---
    for j in 0..decomposition.steps_taken - 1 {
        // Retrieve the scalar coefficients computed during the first pass.
        let alpha_j = T::Real::copy_impl(&decomposition.alphas[j]);
        let beta_j = T::Real::copy_impl(&decomposition.betas[j]);
        let beta_prev = if j == 0 {
            T::Real::zero_impl()
        } else {
            T::Real::copy_impl(&decomposition.betas[j - 1])
        };

        // 1. Regenerate the unnormalized next vector, r_j, using the stored coefficients.
        lanczos_reconstruction_step(
            operator,
            work.as_mut(),
            v_curr.as_ref(),
            v_prev.as_ref(),
            alpha_j,
            beta_prev,
            stack,
        );

        // 2. Normalize the regenerated vector using the stored beta_j. The first pass
        // ensures that beta_j is not numerically zero at this step.
        let inv_beta = T::from_real_impl(&T::Real::recip_impl(&beta_j));
        zip!(work.as_mut()).for_each(|unzip!(w_i)| {
            *w_i = mul(w_i, &inv_beta);
        });
        // `work` now contains the regenerated vector v_{j+1}.

        // 3. Accumulate the final solution vector component-wise: x_k += y_{j+1} * v_{j+1}
        let coeff = T::copy_impl(&y_k[(j + 1, 0)]);
        zip!(x_k.as_mut(), work.as_ref()).for_each(|unzip!(x_i, v_i)| {
            *x_i = add(x_i, &mul(&coeff, v_i));
        });

        // 4. Cycle the vectors for the next iteration using efficient swaps.
        core::mem::swap(&mut v_prev, &mut v_curr);
        core::mem::swap(&mut v_curr, &mut work);

        // 5. If requested, store the regenerated basis vector.
        if let Some(m) = v_k_regen.as_mut() {
            m.col_mut(j + 1).copy_from(v_curr.as_ref().col(0));
        }
    }

    Ok((x_k, v_k_regen))
}
