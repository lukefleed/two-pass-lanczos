//! Integration test suite with a custom harness to verify the mathematical
//! correctness of the Lanczos algorithms on a per-file basis.

use anyhow::{Result, ensure};
use faer::{
    Mat, Par,
    dyn_stack::{MemBuffer, MemStack},
    matrix_free::LinOp,
};
use lanczos_project::{
    algorithms::lanczos::{lanczos_pass_one, lanczos_pass_two_with_basis, lanczos_standard},
    utils::data_loader::load_kkt_system,
};
use rand::{Rng, SeedableRng, rngs::StdRng};
use std::path::PathBuf;

// A tolerance for floating-point comparisons in correctness tests.
const TOLERANCE: f64 = 5e-9;

/// A helper struct to hold paths to a complete test instance.
#[derive(Debug)]
struct TestInstance {
    pub name: String,
    pub dmx_path: PathBuf,
    pub qfc_path: PathBuf,
}

/// Executes the core Lanczos algorithm checks for a single problem instance.
fn run_correctness_test_for_instance(instance: &TestInstance) -> Result<()> {
    // Number of Lanczos iterations to perform.
    let k = 30;

    // Load the matrix from the instance files.
    let kkt_system = load_kkt_system(&instance.dmx_path, &instance.qfc_path)?;
    let a = kkt_system.a;
    let n = a.nrows();

    // Create a reproducible random vector.
    let mut rng = StdRng::seed_from_u64(42);
    let b = Mat::from_fn(n, 1, |_, _| rng.random());

    // Allocate memory for faer operations.
    let mut mem = MemBuffer::new(a.as_ref().apply_scratch(k + 1, Par::Seq));
    let mut stack = MemStack::new(&mut mem);

    // --- Verification 1: Consistency between one-pass and two-pass decomposition ---
    let standard_output = lanczos_standard(&a.as_ref(), b.as_ref(), k, &mut stack, None)?;
    let pass_one_output = lanczos_pass_one(&a.as_ref(), b.as_ref(), k, &mut stack)?;
    ensure!(
        standard_output.decomposition.alphas == pass_one_output.alphas,
        "Alphas mismatch on instance '{}'",
        instance.name
    );
    ensure!(
        standard_output.decomposition.betas == pass_one_output.betas,
        "Betas mismatch on instance '{}'",
        instance.name
    );

    // --- Verification 2: Reconstruction correctness and numerical stability ---
    let steps = standard_output.decomposition.steps_taken;
    let y_k = Mat::from_fn(steps, 1, |_, _| rng.random());
    let x_k_expected = &standard_output.v_k * &y_k;

    // Use the test-only function to get both the solution and the regenerated basis.
    let pass_two_output = lanczos_pass_two_with_basis(
        &a.as_ref(),
        b.as_ref(),
        &pass_one_output,
        y_k.as_ref(),
        &mut stack,
    )?;
    let x_k_reconstructed = pass_two_output.x_k;
    let v_k_regenerated = pass_two_output.v_k;

    // 2a. Check if the final reconstructed solution is correct.
    let recon_error = (&x_k_expected - &x_k_reconstructed).norm_l2();
    ensure!(
        recon_error < TOLERANCE,
        "Reconstruction error on instance '{}' is too high: {}",
        instance.name,
        recon_error
    );

    // --- Verification 3: Orthonormality and Stability Checks ---
    let v_k_standard = standard_output.v_k.as_ref();
    let identity = Mat::<f64>::identity(steps, steps);

    // 3a. Orthonormality of the standard basis.
    let ortho_error_standard = (&identity - v_k_standard.adjoint() * v_k_standard).norm_l2();
    ensure!(
        ortho_error_standard < TOLERANCE,
        "Standard basis on instance '{}' is not orthonormal. Error norm: {}",
        instance.name,
        ortho_error_standard
    );

    // 3b. Orthonormality of the regenerated basis.
    let v_k_regen_ref = v_k_regenerated.as_ref();
    let ortho_error_regen = (&identity - v_k_regen_ref.adjoint() * v_k_regen_ref).norm_l2();
    ensure!(
        ortho_error_regen < TOLERANCE,
        "Regenerated basis on instance '{}' is not orthonormal. Error norm: {}",
        instance.name,
        ortho_error_regen
    );

    // 3c. Numerical drift between the two bases.
    let drift = (v_k_standard - v_k_regen_ref).squared_norm_l2();
    ensure!(
        drift < TOLERANCE,
        "Numerical drift between bases on instance '{}' is too high. Drift norm: {}",
        instance.name,
        drift
    );

    Ok(())
}

/// Macro to generate a test module that includes all dynamically generated
/// test functions from the build script.
macro_rules! generate_correctness_tests {
    () => {
        mod generated {
            // Bring the helper struct and runner function from the parent module into scope.
            use super::*;

            // Include the test functions generated by `build.rs`.
            // The file is located in the `OUT_DIR` directory managed by Cargo.
            include!(concat!(env!("OUT_DIR"), "/correctness_tests.rs"));
        }
    };
}

// Invoke the macro to generate all tests.
generate_correctness_tests!();
