//! Integration test suite to verify the mathematical properties of the
//! Lanczos algorithms on a per-file basis.

use anyhow::{Result, ensure};
use faer::{
    Par,
    dyn_stack::{MemBuffer, MemStack},
    matrix_free::LinOp,
    prelude::*,
};
use lanczos_project::{
    algorithms::lanczos::{lanczos_pass_one, lanczos_pass_two_with_basis, lanczos_standard},
    utils::data_loader::load_kkt_system,
};
use rand::{Rng, SeedableRng, rngs::StdRng};
use std::path::PathBuf;

// A tolerance for floating-point comparisons in property tests.
const TOLERANCE: f64 = 5e-9;

/// A helper struct to hold paths to a complete test instance.
#[derive(Debug)]
struct TestInstance {
    pub name: String,
    pub dmx_path: PathBuf,
    pub qfc_path: PathBuf,
}

/// Verifies that the scalar decompositions from the one-pass and two-pass
/// algorithms are consistent to within floating-point tolerance.
fn run_decomposition_consistency_test_for_instance(instance: &TestInstance) -> Result<()> {
    let k = 30;
    let kkt_system = load_kkt_system(&instance.dmx_path, &instance.qfc_path)?;
    let a = kkt_system.a;
    let n = a.nrows();
    let mut rng = StdRng::seed_from_u64(42);
    let b = Mat::from_fn(n, 1, |_, _| rng.random());

    let mut mem = MemBuffer::new(a.as_ref().apply_scratch(1, Par::Seq));
    let mut stack = MemStack::new(&mut mem);

    let standard_output = lanczos_standard(&a.as_ref(), b.as_ref(), k, &mut stack, None)?;
    let pass_one_output = lanczos_pass_one(&a.as_ref(), b.as_ref(), k, &mut stack)?;

    ensure!(
        standard_output.decomposition.steps_taken == pass_one_output.steps_taken,
        "steps_taken mismatch on instance '{}'",
        instance.name
    );

    for (i, (alpha_std, alpha_po)) in standard_output
        .decomposition
        .alphas
        .iter()
        .zip(pass_one_output.alphas.iter())
        .enumerate()
    {
        let diff = (alpha_std - alpha_po).abs();
        ensure!(
            diff < TOLERANCE,
            "Alpha mismatch at index {} on instance '{}'. Diff: {}",
            i,
            instance.name,
            diff
        );
    }

    for (i, (beta_std, beta_po)) in standard_output
        .decomposition
        .betas
        .iter()
        .zip(pass_one_output.betas.iter())
        .enumerate()
    {
        let diff = (beta_std - beta_po).abs();
        ensure!(
            diff < TOLERANCE,
            "Beta mismatch at index {} on instance '{}'. Diff: {}",
            i,
            instance.name,
            diff
        );
    }

    Ok(())
}

/// Verifies that the fundamental Lanczos relation A*V_k - V_k*T_k = beta_k*v_{k+1}*e_k^T
/// holds for the standard algorithm.
fn run_lanczos_relation_test_for_instance(instance: &TestInstance) -> Result<()> {
    let k = 30;
    let kkt_system = load_kkt_system(&instance.dmx_path, &instance.qfc_path)?;
    let a = kkt_system.a;
    let n = a.nrows();
    let mut rng = StdRng::seed_from_u64(42);
    let b = Mat::from_fn(n, 1, |_, _| rng.random());

    let mut mem = MemBuffer::new(a.as_ref().apply_scratch(1, Par::Seq));
    let mut stack = MemStack::new(&mut mem);

    let result_k = lanczos_standard(&a.as_ref(), b.as_ref(), k, &mut stack, None)?;
    let result_k_plus_1 = lanczos_standard(&a.as_ref(), b.as_ref(), k + 1, &mut stack, None)?;

    let v_k = result_k.v_k.as_ref();
    let beta_k = result_k_plus_1.decomposition.betas[k - 1];
    let v_k_plus_1 = result_k_plus_1.v_k.as_ref().get(.., k..k + 1);

    let t_k_mat = {
        let mut t = Mat::zeros(k, k);
        for i in 0..k {
            t.as_mut()[(i, i)] = result_k.decomposition.alphas[i];
        }
        for i in 0..k - 1 {
            t.as_mut()[(i, i + 1)] = result_k.decomposition.betas[i];
            t.as_mut()[(i + 1, i)] = result_k.decomposition.betas[i];
        }
        t
    };

    let mut e_k = Mat::zeros(k, 1);
    e_k.as_mut()[(k - 1, 0)] = 1.0;

    let residual_matrix = a.as_ref() * v_k - v_k * t_k_mat;
    let expected_residual_matrix = v_k_plus_1 * e_k.as_ref().adjoint() * Scale(beta_k);

    let norm_diff = (residual_matrix - expected_residual_matrix).norm_l2();
    ensure!(
        norm_diff < TOLERANCE,
        "Lanczos relation does not hold on instance '{}'. Diff norm: {}",
        instance.name,
        norm_diff
    );

    Ok(())
}

/// Verifies that the basis vectors generated by the standard one-pass algorithm and
/// regenerated by the two-pass algorithm are orthonormal.
fn run_orthonormality_test_for_instance(instance: &TestInstance) -> Result<()> {
    let k = 30;
    let kkt_system = load_kkt_system(&instance.dmx_path, &instance.qfc_path)?;
    let a = kkt_system.a;
    let n = a.nrows();
    let mut rng = StdRng::seed_from_u64(42);
    let b = Mat::from_fn(n, 1, |_, _| rng.random());

    let mut mem = MemBuffer::new(a.as_ref().apply_scratch(1, Par::Seq));
    let mut stack = MemStack::new(&mut mem);

    let standard_output = lanczos_standard(&a.as_ref(), b.as_ref(), k, &mut stack, None)?;
    let v_k_standard = standard_output.v_k.as_ref();
    let steps = standard_output.decomposition.steps_taken;
    let identity = Mat::<f64>::identity(steps, steps);
    let ortho_error_standard = (&identity - v_k_standard.adjoint() * v_k_standard).norm_l2();
    ensure!(
        ortho_error_standard < TOLERANCE,
        "Standard basis on instance '{}' is not orthonormal. Error norm: {}",
        instance.name,
        ortho_error_standard
    );

    let pass_one_output = lanczos_pass_one(&a.as_ref(), b.as_ref(), k, &mut stack)?;
    let y_k = Mat::from_fn(steps, 1, |_, _| rng.random());
    let pass_two_output = lanczos_pass_two_with_basis(
        &a.as_ref(),
        b.as_ref(),
        &pass_one_output,
        y_k.as_ref(),
        &mut stack,
    )?;
    let v_k_regenerated = pass_two_output.v_k.as_ref();
    let ortho_error_regen = (&identity - v_k_regenerated.adjoint() * v_k_regenerated).norm_l2();
    ensure!(
        ortho_error_regen < TOLERANCE,
        "Regenerated basis on instance '{}' is not orthonormal. Error norm: {}",
        instance.name,
        ortho_error_regen
    );

    Ok(())
}

/// Verifies the numerical stability of the two-pass method by measuring the
/// drift between the standard and regenerated Lanczos bases.
fn run_reconstruction_stability_test_for_instance(instance: &TestInstance) -> Result<()> {
    let k = 30;
    let kkt_system = load_kkt_system(&instance.dmx_path, &instance.qfc_path)?;
    let a = kkt_system.a;
    let n = a.nrows();
    let mut rng = StdRng::seed_from_u64(42);
    let b = Mat::from_fn(n, 1, |_, _| rng.random());

    let mut mem = MemBuffer::new(a.as_ref().apply_scratch(1, Par::Seq));
    let mut stack = MemStack::new(&mut mem);

    let standard_output = lanczos_standard(&a.as_ref(), b.as_ref(), k, &mut stack, None)?;
    let v_k_standard = standard_output.v_k.as_ref();
    let steps = standard_output.decomposition.steps_taken;

    let pass_one_output = lanczos_pass_one(&a.as_ref(), b.as_ref(), k, &mut stack)?;
    let y_k = Mat::from_fn(steps, 1, |_, _| rng.random());
    let pass_two_output = lanczos_pass_two_with_basis(
        &a.as_ref(),
        b.as_ref(),
        &pass_one_output,
        y_k.as_ref(),
        &mut stack,
    )?;
    let v_k_regenerated = pass_two_output.v_k.as_ref();

    let drift = (v_k_standard - v_k_regenerated).squared_norm_l2();
    ensure!(
        drift < TOLERANCE,
        "Numerical drift between bases on instance '{}' is too high. Drift norm: {}",
        instance.name,
        drift
    );

    Ok(())
}

/// Macro to generate a test module that includes all dynamically generated
/// test functions from the build script.
macro_rules! generate_property_tests {
    () => {
        mod generated {
            use super::*;
            include!(concat!(env!("OUT_DIR"), "/properties_tests.rs"));
        }
    };
}

generate_property_tests!();
