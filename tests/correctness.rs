//! Integration test suite with a custom harness to verify the mathematical
//! correctness of the Lanczos algorithms on a per-file basis.

use anyhow::{Result, ensure};
use faer::{
    Mat, Par,
    dyn_stack::{MemBuffer, MemStack},
    matrix_free::LinOp,
};
use lanczos_project::{
    algorithms::lanczos::{lanczos_pass_one, lanczos_pass_two, lanczos_standard},
    utils::data_loader::load_kkt_system,
};
use rand::{Rng, SeedableRng, rngs::StdRng};
use std::path::PathBuf;

// A tolerance for floating-point comparisons in correctness tests.
const TOLERANCE: f64 = 1e-12;

/// A helper struct to hold paths to a complete test instance.
#[derive(Debug)]
struct TestInstance {
    pub name: String,
    pub dmx_path: PathBuf,
    pub qfc_path: PathBuf,
}

/// Executes the core Lanczos algorithm checks for a single problem instance.
fn run_correctness_test_for_instance(instance: &TestInstance) -> Result<()> {
    // Number of Lanczos iterations to perform.
    let k = 30;

    // Load the matrix from the instance files.
    let kkt_system = load_kkt_system(&instance.dmx_path, &instance.qfc_path)?;
    let a = kkt_system.a;
    let n = a.nrows();

    // Create a reproducible random vector.
    let mut rng = StdRng::seed_from_u64(42);
    let b = Mat::from_fn(n, 1, |_, _| rng.random());

    // Allocate memory for faer operations.
    let mut mem = MemBuffer::new(a.as_ref().apply_scratch(k + 1, Par::Seq));
    let mut stack = MemStack::new(&mut mem);

    // --- Verification 1: Consistency between one-pass and two-pass decomposition ---
    let standard_output = lanczos_standard(&a.as_ref(), b.as_ref(), k, &mut stack, None)?;
    let pass_one_output = lanczos_pass_one(&a.as_ref(), b.as_ref(), k, &mut stack)?;
    ensure!(
        standard_output.decomposition.alphas == pass_one_output.alphas,
        "Alphas mismatch on instance '{}'",
        instance.name
    );
    ensure!(
        standard_output.decomposition.betas == pass_one_output.betas,
        "Betas mismatch on instance '{}'",
        instance.name
    );

    // --- Verification 2: Reconstruction correctness ---
    let steps = standard_output.decomposition.steps_taken;
    let y_k = Mat::from_fn(steps, 1, |_, _| rng.random());
    let x_k_expected = &standard_output.v_k * &y_k;
    let x_k_reconstructed = lanczos_pass_two(
        &a.as_ref(),
        b.as_ref(),
        &pass_one_output,
        y_k.as_ref(),
        &mut stack,
    )?;
    let recon_error = (&x_k_expected - &x_k_reconstructed).norm_l2();
    ensure!(
        recon_error < TOLERANCE,
        "Reconstruction error on instance '{}' is too high: {}",
        instance.name,
        recon_error
    );

    // --- Verification 3: Orthonormality of the basis ---
    let v_k = standard_output.v_k.as_ref();
    let identity = Mat::<f64>::identity(steps, steps);
    let ortho_error = (&identity - v_k.adjoint() * v_k).norm_l2();
    ensure!(
        ortho_error < TOLERANCE,
        "Basis on instance '{}' is not orthonormal. Error norm: {}",
        instance.name,
        ortho_error
    );

    Ok(())
}

/// Macro to generate a test module that includes all dynamically generated
/// test functions from the build script.
macro_rules! generate_correctness_tests {
    () => {
        mod generated {
            // Bring the helper struct and runner function from the parent module into scope.
            use super::*;

            // Include the test functions generated by `build.rs`.
            // The file is located in the `OUT_DIR` directory managed by Cargo.
            include!(concat!(env!("OUT_DIR"), "/correctness_tests.rs"));
        }
    };
}

// Invoke the macro to generate all tests.
generate_correctness_tests!();
